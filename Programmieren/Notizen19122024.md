15 % 4 = 3
15 / 2.0 = 7.5
3 + 5 % 4 = 3 + 1 = 4
3 \* 7 % 4 = 21 % 4 = 1

\[x = \[\[(- 4) \* (++ i)] - (6 % 4)]];

x = 7;
x < 9 && x >= -5; 
--> TRUE

x = 7;
!x && x >= 3;
--> FALSE

x = 7;
x++ = 8 || x == 7;
--> TRUE

%3.2f: 
3: Es gibt insgesamt 3 Felder
2: Nachkommastellenpräzsision

Wegen Codeoptimierung kann der Compiler einfach manche Variablen nicht berechnen!

In Binär (char: 1 Byte)
3 -> 0000 0011
15 -> 0000 1111
-119 -> 1000 1001
0 -> 0000 0000
42 -> 0010 1010

In Binär (signed short: 2 Bytes)
16866 -> 0100 0001 1110 0010
'x' -> 0000 0000 0100 1110
-99 -> 1111 1111 1001 1101
13,5 -> 0000 0000 0000 1101
-42 -> 1111 1111 1101 0100

In Dezimal (signed short: 2 Bytes)
0000 0011 0000 0000 -> 768
0000 0110 1010 1100 -> 1708
1111 1111 1111 1111 -> -1

Characteristik: Zahlenrange/Zahlenraum
Mantisse: Genauigkeit

Wert für Floating Point:
value = (-1)^(sign) \* (1 + Mantissa) \* 2^(Characteristic - BIAS)
42.0 = (-1)^(0) \* (1+0) \* 2

z.B. 1 395 717, 1597
Kann nicht mehr in Float dargestellt werden, weil Float eine Genauigkeit von 10⁷ hat. Die Zahl wird in 1,395... \* 10⁷ dargestellt, was es nicht möglich macht, nach der ,1 Zahlen darzustellen.
-> In dem Fall muss man Double verwenden.

